Для сборки проекта потребуется:

* установленный netcore 1.1
* node.js с npm (устанавливаются вместе)
* bower
* java (JDK или JRE) - для сборки фронта используется closure compiler, ему нужна java

```
git clone https://github.com/gonzazoid/WeatherApp.git
cd WeatherApp
npm install // для установки пакетов необходимых для сборки фронтенда
npm install -g bower // возможно придется ставить под sudo

dotnet restore
dotnet build

// если запускаете приложение на своей базе - нужны миграции
dotnet ef migrations add InitialCreate
dotnet ef database update

// если на мой базе - верхние две строки пропускаем

// запуск приложения:

DB_PWD=пароль_от_базы dotnet run
```
*UPDATE по тестам и провайдерам*
- Как это всё можно оттестировать? Хорошо бы добавить сборку с тестами к провайдерам. Стоит использовать NUnit. Жду коммит.

использовал NUnit и Moq. Всего три теста, покрывают работу checkPlaceOpenWeatherAsync в первой версии (ветка first_tests) или CheckPlaceAsync в ветке data_providers_interface.

- Нужно добавить ещё 1 поставщика данных. (можно на основе хоть openweather хоть yahoo). Жду коммит.
- А если надо добавить ещё 10? Как изменится структура проекта и структура бд. А что если его будет делать сторонний разработчик?
Что ему надо будет отдать, чтобы потом можно было безболезненно подключить к нам не имея его иходников. Код не нужен, просто словами.

Это один и тот же вопрос заданный разными словами. Если у нас есть два поставщика и мы реализовали их как два частных случая, то третий - это по любому система и уже не важно сколько их - 3 или 30. Поэтому я частично реализовал схему в том числе с возможностью передать разработку на оутсорс. Все это в ветке data_providers_interface. Логика простая - мы хотим что бы добавление нового провайдера происходило безболезненно, с минимум телодвижений и минимумом изменяемого кода. В идеале - без изменений кода, просто добавлением класса в проект.
Тут все понятно - какой то список или массив объектов, соотв. провайдерам, все реализуют какой то метод, запрашивающий состояние погоды и возвращающий ее в виде удобном для хранения в базе. Вопрос стоит только в создании такого массива или списка. Заранее мы не знаем сколько у нас провайдеров. Тут два очевидных решения - жестко в годе прописывать создание объектов(тогда придется править это место каждый раз при добавлении нового провайдера) или составлять этот список в рантайме(использовать рефлексию). Я решил через рефлексию - прокачать скилы + это позволяет реализовать бесшовную интеграцию (именно позволяет, я полностью без швов не реализовал, ниже подробнее)

В системе заводим класс WeatherProviders который и будет хранить всех провайдеров. Для провайдеров заводим интерфейс IWeatherProvider - каждый провайдер должен его реализовать иначе мы его не видим и не умеем с ним работать.
Вся работа по интеграции ведется в Startup.ConfigureServices. Мы получаем список всех классов в текущей сборке которые реализуют интерфейс IWeatherProvider, каждый из них инстанциируем (c DI, так что все имеющиеся в наличии сервисы пробрасываются), запечатываем список и регистрируем его синглтоном. Следующее изменение - WeatherChecker, он упрощается так как ему не надо знать ничего о провайдерах, он получает от WeatherProviders список стейтов, проходит по ним добавляя стамп и PlaceId (это детали хранения и провайдеры о них ничего знать не должны) и кладет в базу.
Что касается базы - в ней не меняется ничего. Структура остается прежней. Также остается прежней (пока) выборка из базы. То есть при запросе отдаются данные всех провайдеров, на клиенте jqGrid использует нужные (это тема для UX)
Итого - как добавляется новый провайдер? Просто кладем класс провайдера в директорию Providers (понятно то можно в любую другую но пусть будет порядок) - и пересобираем проект. Требования к классу - он должен реализовывать интерфейс IWeatherProvider и иметь уникальный .name (проверка на уникальность name не реализована, но это несложно). То есть уже не принципиально - 1 или 100 провайдеров добавляем.
Именно так добавлен провайдер Yahoo2 - скопировал файл оригинального провайдера и поменял имя класса, конструктора и .name. Этого хватило для того что бы Startup его подхватил и добавил в список.

Что не реализовано? (тех долг) Очевидно провайдеры захотят что то брать из конфига. Сейчас конфиг пробрасывается сервисом и каждый провайдер получает полный конфиг. Тут правильнее было бы что бы каждый провайдер объявлял структуру своей части конфига, которая встраивалась бы в общий конфиг скажем в Providers.[provider name] и потом в конструктор пробрасывалась бы именно эта часть конфига. Реализовывать не стал, на словах распишу - схема такая же, через рефлексию. Вытаскиваем список классов, реализующих интерфейс провайдера, смотрим их конструкторов и составляем спиcок ожидаемых типов параметров (точнее интерфейсов), оставлем все кто отнаследовался от определенного интерфейса (скажем IProvidersConfig, может быть пустым, это просто маркер, хотя MS не рекомендует, но кастомный аттрибут на мой взгляд будет смотреться неуклюже) и по полученному списку создаем экземпляры(с соотв. данными из конфига) и регистрируем синглтоны - ДО того как будут создаваться экземпляры провайдеров.
Примерно в том же ключе можно собирать тип для общего конфига для строгой типизации.
И туда же - модели для проверки валидности ответа (от серверов), но тут надо думать, если мы не предоставим удобный интерфейс для быстрого построения валидатора - смысла в этом нет.

Как в этой схеме поменялись тесты? Я не стал менять тесты - так же тестируется только openWeather, только метод checkPlace. Но (если держать в голове что мы хотим передать эту часть на оутсорс) напрашивается следующая схема. Мы реализовываем родительский класс тестов (абстрактный) и прописываем в нем все тесты которые должен проходить каждый провайдер - то есть общую часть. Разработчик наследуется от этого класса и добавляет свои тесты (специфичные именно для этой реализации провайдера)

Таким образом, плавно переходя к вопросу о том что мы передаем разработчику, получается следующее:
интерфейс IWeatherProvider
класс тестов (абстрактный)
список сервисов (не весь но тот что может пригодится в разработке)

что получаем от разработчика:
класс провайдера
класс конфигурации (используем для построения типа для строгой типизизации конфига)
классы-модели ответов серверов для построения валидаторов (под вопросом, тут надо думать)
тесты

Описанная схема предполагает что исполнитель вернет исходники. Если исходников нет то пока у меня понимание процесса слабое, поэтому могу ошибиться, но думаю что исполнитель должен собирать модуль (/target:module) а мы соотв. добавляем полученный .netmodule в свою сборку через /addmodule. Собственно изменения только в сборке, все вышесказанное должно работать (но надо проверить на практике, еще руки не дошли)
Собственно пока все.

*конец апдейта*

Немного вкратце опишу по коду:

В условиях к задаче указывались требования:

* MS VisualStudio 2010
* .Net 4.0
* ASP.NET MVC4
* MSSQL Express for data storage
* jqGrid
* DI/IoC via Microsoft.Practices.Unity
* Data access via Entity CodeFirst
* Dependencies loaded via NuGet

К сожалению виндовой машины у меня под рукой нет (так что бы сесть и днями на ней работать), есть мак а на нем ставится только net core, собственно под нее и писал. Причем вторая не встала, писал под 1.1. В принципе сейчас разобрался уже достаточно, если это принципиальный момент - могу переписать и под .Net 4.0 (не стал сразу этого делать ввиду и без того затянувшихся сроков)

Отсюда же отсутствие Unity - в net core свой IoC, использовал его.

Отсюда же отсутствие jqGrid на сервере - под net core этой либы нет(обработка запросов на бэке), принимаю запросы ручками.

На счет VisualStudio - я так понял это требование к тому что проект должен собираться в этой IDE. в общем я работаю в vim-е, собирал с консоли, в VisualStudio должно собираться без проблем, никаких расширений и прочих плюшек не использовалось.

Относительно сборки - сервер собирается стандартно, для сборки фронтенда - я отключил то что стояло по умолчанию и подкрутил webpack. Фронт (громко сказано, там по сути всего два скрипта собираются) написан на typescript, прогоняется через линтер и сжимается closure compiler-ом. Остался рудимент в виде подкачки пакетов bowler-ом, его не стал пока трогать, вынес в npm скрипт, но вообще на реальном  проекте управление пакетами лучше отдать npm и нарезать бандл через webpack. Да, и по поводу дальнейшего развития - работать с jqGrid напрямую - это лапша в коде и ее даже модулями не особо спрячешь, если использовать в серьезном проекте (широком и долгострочном) то конечно лучше бы jqGrid обвернуть во что нибудь (react компонента, custom element, в общем исходя из того что используется)

Теперь по серверу.

Прежде чем продолжу, напомню - это тест скорее не на то как я могу написать back а на то насколько я разобрался в шарпах и стеке .Net за три недели. То есть вообще не настаиваю на решениях, к критике готов )

Из реализованного:
* strongly typed options, то есть у опций своя модель и они сервисом пробрасываются по коду.
* параметры запросов из json-а биндятся в объекты (на этом этапе проверки через аннотации) + прикрутил проверки fluentvalidation
* ответы провайдеров тоже описал моделями, также проверки на аннотациях, fluentvalidation прикрутил но правила не указал - аннотаций хватило, валидацию оставил для полноты, на развитие. И еще момент - yahoo давление отдает непонятнов чем, это не миллибары, несмотря на то что они указаны в юнитах. С этим не разобрался, в общем тех. долг.
* с правилами валидации немного поиграл с наследованием, на таком объеме не принципиально, но если писать полноценный API - то очень удобно.
* запросы отрабатываются асинхронно, с базой тоже в большинстве случаев работа асинхронная.
* по ORM особо сказать нечего, единственное - удаление сущностей реализовал каскадом.
* опрос провайдеров информации реализовал через hangFire, тут не настаиваю - просто пробежался по форумам, посмотрел обзоры таск менеджеров, его хвалили больше всего. Частота опроса - в настройках, cron expression. На сайте - ссылка HangFire - можно посмотреть нагрузку.

Кстати о нагрузке - поскольку непонятно с каким объемом данных придется работать я заложился на две точки роста для масштабирования. Если по мере роста проекта объемы будут расти (увеличивается число отслеживаемых городов/уменьшается интервал опроса) то будет необходим менеджер нагрузки. Его можно будет впилить либо в WeatherChecker - это то место где есть данные по объему предстоящей работы, либо в UserAgent - там данных нет, это обертка вокруг WebRequest, я ее ввел сознательно - если что можно быстро этот сервис сделать синглтоном и аккумулировать запросы, обрабатывая согласно настройкам (например пакетами по десять с перерывом в пять минут и тому подобное).

По теме развития - можно еще предположить что будет увеливаться число провайдеров, но здесь я особо не стал углубляться. Чекеры сидят методами в WeatherProviders, если реально надо больше двух провайдеров - то на мой взгляд лучше тогда каждый чекер оформлять сервисом, но тогда потребуется свой service locator. В общем оно сейчас собрано в одном месте, если что - можно быстро переделать. Небольшой задел на будущее без преждевременного усложнения.

По обработке ошибок - поставил кетчи, но поскольку нет условий в ТЗ - ничего не делаю. Все места перехвата выводятся в warnings, не убрал сознательно что бы всегда было видно. По warnings - первые два - это от tslinter-а, это нормально, там ишью по tslint-loader-у, ждем пока исправят (в конфиге вебпака есть ссылка)

Да, поскольку обработку jqGrid запросов делаю своим велосипедом - я не стал уже писать поиск, новых скилов это не продемонстрирует, просто много рутинной работы. Работает добавление, редактирование, пейджинг и сортировка.

Оба приложения (веб-сервер и чекер) используют Startup, у каждого свой набор сервисов, но я не стал разделять на два отдельных класса. Если это потребуется (например если мы захотим чекер вынести в отдельное приложение) то Startup надо будет разделять на базовый и два унаследованных, в наследуемых - реализовать соотв. ConfigureServices. Я к тому что это не реализовано (на таком объеме кода - это излишнее усложнение) - но я это вижу и по мере роста проекта этот момент должен быть учтен.

Да, по базе. Во первых на маке MSSQL не ставится, поэтому я базу взял на azure, думаю это не принципиальный момент. Второй момент - все время пока я програмил база у меня создавалась с кода (dbContext.Database.EnsureCreated()) причем реально создавалась, я помню как менял структуру и эти изменения заливались. Перед тем как отправлять код решил пройти процесс с нуля, снес базу и на этом все, EnsureCreated лезет на абсолютно чистую базу и сообщает что там все есть, ничего делать не надо. В чем дело - я так и не осилил, поэтому пока на миграциях.

В принципе все, дальше только код смотреть. Пароль к базе вышлю почтой.
